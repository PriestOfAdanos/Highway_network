# -*- coding: utf-8 -*-
"""Highway.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UI5vjHBNCvkWK8XMNTvBbdM4Edw0t8pK
"""

import torch
import torch.nn as nn
import torchvision
import matplotlib as plt
from torch.autograd import Variable
from torchvision import datasets, transforms
from torch.nn import  functional as F

mnist = torchvision.datasets.MNIST('data/MNIST', train=True, download = True, transform = transforms.Compose([ transforms.ToTensor(), transforms.Normalize([0.1307], [0.3081])]))

train_loader = torch.utils.data.DataLoader(mnist, batch_size = 1)
iterloader = iter(train_loader)

class Highway(nn.Module):
  def __init__(self, IO_size):
    super().__init__()
    self.linear = nn.Linear(IO_size,IO_size, bias = True)
    self.transform = nn.Linear(IO_size,IO_size, bias=True)
    self.transform.bias.data.fill_(-2.0)
  
  def forward(self,x):
    H = F.softmax(self.linear(x))
    T = F.relu(self.transform(x))
    return H*T+x*(1-T)

class Net(nn.Module):
  def __init__(self):
    super().__init__()
    self.highws = nn.ModuleList([Highway(10) for _ in range(20)]) # Amount of layers
    self.linear1 = nn.Linear(784,128)
    self.linear2  = nn.Linear(128,10)
    self.softmax = nn.Softmax(dim=1)
    self.relu1 = nn.ReLU()
    self.relu2 = nn.ReLU()
  def forward(self,x):
    x = self.linear1(x)
    x = F.relu(x)
    x = self.linear2(x)
    x = F.relu(x)
    for highway in self.highws:
            x = highway(x)
    return self.softmax(x)

model = Net()

criterion = torch.nn.MSELoss()
optimizer = torch.optim.SGD(model.parameters(), lr=0.01)
values = []

"""The code runs for a very long time so I summarrized the results

35 layers of Highway

loss of epoch nr. 0: 5107.05224609375

loss of epoch nr. 1: 4034.858154296875

loss of epoch nr. 2: 3053.786865234375

loss of epoch nr. 3: 2471.9052734375

loss of epoch nr. 4: 2133.5595703125
"""

for e in range(5):
  epoch_loss = 0
  i=0
  iterloader = iter(train_loader)
  for image, label in iterloader:
    i+=1
    target = torch.tensor([0]*10)
    target = target.to(dtype=torch.float32)
    target[label-1]=1
    optimizer.zero_grad()
    output = model.forward(image.view(1,784))
    loss = criterion(torch.squeeze(output), target)
    loss.backward() 
    optimizer.step()
    epoch_loss+=loss
    if i%100==0:print("{}/{}: {}".format(e,i,loss))
  print("loss of epoch nr. {}: {}".format(e, epoch_loss))
  values.append(epoch_loss)

images, labels = next(iter(valloader))

img = images[0].view(1, 784)
with torch.no_grad():
    logps = model(img)

ps = torch.exp(logps)
probab = list(ps.numpy()[0])
print("Predicted Digit =", probab.index(max(probab)))
view_classify(img.view(1, 28, 28), ps)

correct_count, all_count = 0, 0
for images,labels in valloader:
  for i in range(len(labels)):
    img = images[i].view(1, 784)
    with torch.no_grad():
        logps = model(img)

    
    ps = torch.exp(logps)
    probab = list(ps.numpy()[0])
    pred_label = probab.index(max(probab))
    true_label = labels.numpy()[i]
    if(true_label == pred_label):
      correct_count += 1
    all_count += 1

print("Number Of Images Tested =", all_count)
print("\nModel Accuracy =", (correct_count/all_count))

